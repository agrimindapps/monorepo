import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../../core/providers/core_providers.dart';
import '../../domain/entities/index.dart';
import '../../domain/usecases/get_current_subscription.dart';
import '../models/user_subscription_model.dart';
import '../notifiers/billing_notifier.dart';
import '../notifiers/purchase_notifier.dart';
import '../notifiers/subscription_status_notifier.dart';
import '../notifiers/trial_notifier.dart';
import '../services/subscription_error_message_service.dart';

part 'subscription_provider.g.dart';

// ═══════════════════════════════════════════════════════════════
// SERVICE & USECASE PROVIDERS
// ═══════════════════════════════════════════════════════════════

@riverpod
SubscriptionErrorMessageService subscriptionErrorMessageService(Ref ref) {
  return SubscriptionErrorMessageService();
}

@riverpod
GetCurrentSubscriptionUseCase getCurrentSubscriptionUseCase(Ref ref) {
  final repository = ref.watch(subscriptionRepositoryProvider);
  return GetCurrentSubscriptionUseCase(repository);
}

// ═══════════════════════════════════════════════════════════════
// INDIVIDUAL NOTIFIER PROVIDERS (Generated by @riverpod in notifiers)
// ═══════════════════════════════════════════════════════════════

/// Provider do SubscriptionStatusNotifier (gerado por @riverpod)
/// Gerencia estado de subscription do usuário
///
/// Nome gerado: subscriptionStatusNotifierProvider
// Note: Provider é automaticamente gerado pelo notifier's @riverpod annotation

/// Provider do TrialNotifier (gerado por @riverpod)
/// Gerencia estado de trial do usuário
///
/// Nome gerado: trialNotifierProvider
// Note: Provider é automaticamente gerado pelo notifier's @riverpod annotation

/// Provider do BillingNotifier (gerado por @riverpod)
/// Gerencia problemas de cobrança
///
/// Nome gerado: billingNotifierProvider
// Note: Provider é automaticamente gerado pelo notifier's @riverpod annotation

/// Provider do PurchaseNotifier (gerado por @riverpod)
/// Gerencia histórico de compras
///
/// Nome gerado: purchaseNotifierProvider
// Note: Provider é automaticamente gerado pelo notifier's @riverpod annotation

// ═══════════════════════════════════════════════════════════════
// COMPOSITE PROVIDER
// ═══════════════════════════════════════════════════════════════

/// Provider principal que combina todos os notifiers
///
/// Este provider:
/// - Watches todos os 4 notifiers individuais
/// - Recomputa agregação sempre que algum muda
/// - Fornece view única e tipada via UserSubscriptionModel
/// - Oferece getters convenientes para UI
///
/// Uso na UI:
/// ```dart
/// final userSubscription = ref.watch(userSubscriptionProvider);
///
/// if (userSubscription.hasActiveSubscription) {
///   // Render premium content
/// }
/// ```
@riverpod
UserSubscriptionModel userSubscription(Ref ref) {
  // Obter dependências necessárias para subscriptionStatusProvider
  final errorService = ref.watch(subscriptionErrorMessageServiceProvider);
  final getCurrentSubscription = ref.watch(getCurrentSubscriptionUseCaseProvider);

  // Watch todos os 4 notifiers (AsyncValue<State>)
  final subscriptionAsync = ref.watch(
    subscriptionStatusProvider(errorService, getCurrentSubscription),
  );
  final trialAsync = ref.watch(trialProvider);
  final billingAsync = ref.watch(billingProvider);
  final purchaseAsync = ref.watch(purchaseProvider);

  // Extrair estados com null-safety
  final subscriptionState = subscriptionAsync.value;
  final trialState = trialAsync.value;
  final billingState = billingAsync.value;
  final purchaseState = purchaseAsync.value;

  // Agregar em um único modelo (com fallbacks seguros)
  return UserSubscriptionModel(
    // Dados de subscription
    subscription: subscriptionState?.subscription,
    subscriptionLoading: subscriptionAsync.isLoading,
    subscriptionError: subscriptionState?.error,

    // Dados de trial
    trial: trialState?.trial,
    trialLoading: trialAsync.isLoading,
    trialError: trialState?.error,

    // Dados de cobrança
    billingIssues: billingState?.issues ?? [],
    billingLoading: billingAsync.isLoading,
    billingError: billingState?.error,

    // Dados de compras
    purchases: purchaseState?.purchases ?? [],
    purchasesLoading: purchaseAsync.isLoading,
    purchasesError: purchaseState?.error,
  );
}

// ═══════════════════════════════════════════════════════════════
// HELPER PROVIDERS (Derived/Computed)
// ═══════════════════════════════════════════════════════════════

/// Provider que indica se usuário tem acesso premium
///
/// Útil para condicionar renderização de features premium
///
/// Uso:
/// ```dart
/// final hasPremiumAccess = ref.watch(hasPremiumAccessProvider);
/// if (hasPremiumAccess) { /* render premium */ }
/// ```
@riverpod
bool hasPremiumAccess(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.hasActiveSubscription;
}

/// Provider que indica se há atenção necessária
///
/// Retorna true se:
/// - Subscription expirando em breve
/// - Trial expirando em breve
/// - Problemas críticos de billing
/// - Compras pendentes
///
/// Útil para mostrar badge/notificação na UI
@riverpod
bool needsUserAttention(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.needsUserAttention;
}

/// Provider que retorna próxima ação recomendada
///
/// Valores possíveis:
/// - fixBillingIssue
/// - convertTrialToSubscription
/// - renewSubscription
/// - purchaseSubscription
/// - retryFailedPurchase
/// - updatePaymentMethod
/// - null (nenhuma ação recomendada)
///
/// Útil para mostrar CTA (Call-To-Action) prioritário
@riverpod
UserAction? recommendedUserAction(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.recommendedAction;
}

/// Provider que retorna banner prioritário para exibir
///
/// Retorna o banner mais importante baseado em:
/// 1. Problemas críticos de billing
/// 2. Trial expirando
/// 3. Subscription expirando
/// 4. Sem acesso
///
/// Useful para Top Banner da app
@riverpod
PriorityBanner? priorityBanner(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.priorityBanner;
}

/// Provider que retorna status compacto para exibir
///
/// Exemplos:
/// - "⚠️ Problema de cobrança"
/// - "⏰ Trial expirando em 3d"
/// - "✅ Premium Ativo"
/// - "❌ Sem acesso"
///
/// Útil para badges e status indicadores
@riverpod
String statusSummary(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.statusSummary;
}

/// Provider que retorna status de acesso
///
/// Valores:
/// - AccessStatus.subscriptionActive
/// - AccessStatus.trialActive
/// - AccessStatus.gracePeriod
/// - AccessStatus.noAccess
@riverpod
AccessStatus accessStatus(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.accessStatus;
}

/// Provider que indica se há problemas de cobrança pendentes
@riverpod
bool hasBillingIssues(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.hasBillingIssues;
}

/// Provider que indica se há problemas críticos de cobrança
@riverpod
bool hasCriticalBillingIssues(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.hasCriticalBillingIssues;
}

/// Provider que retorna todos os erros agregados
@riverpod
List<String> allErrors(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.allErrors;
}

/// Provider que indica se alguma operação está em progresso
@riverpod
bool isLoading(Ref ref) {
  final subscription = ref.watch(userSubscriptionProvider);
  return subscription.isLoading;
}

// ═══════════════════════════════════════════════════════════════
// ACTION PROVIDERS (Family)
// ═══════════════════════════════════════════════════════════════

/// Provider para ações comuns em subscription
///
/// Permite chamar métodos dos notifiers através do Riverpod
///
/// Uso:
/// ```dart
/// final subscriptionActions = ref.read(subscriptionActionsProvider);
/// await subscriptionActions.loadAll();
/// await subscriptionActions.upgradeSubscription(newTier, 'monthly');
/// ```
@riverpod
SubscriptionActions subscriptionActions(Ref ref) {
  // Obter dependências necessárias para subscriptionStatusProvider
  final errorService = ref.read(subscriptionErrorMessageServiceProvider);
  final getCurrentSubscription = ref.read(getCurrentSubscriptionUseCaseProvider);

  final subscriptionNotifier = ref.read(
    subscriptionStatusProvider(errorService, getCurrentSubscription).notifier,
  );
  final trialNotifier = ref.read(trialProvider.notifier);
  final billingNotifier = ref.read(billingProvider.notifier);
  final purchaseNotifier = ref.read(purchaseProvider.notifier);

  return SubscriptionActions(
    subscriptionNotifier: subscriptionNotifier,
    trialNotifier: trialNotifier,
    billingNotifier: billingNotifier,
    purchaseNotifier: purchaseNotifier,
  );
}

// ═══════════════════════════════════════════════════════════════
// SUBSCRIPTION ACTIONS CLASS
// ═══════════════════════════════════════════════════════════════

/// Classe que agrupa ações comuns de subscription
///
/// Fornece interface simplificada para UI chamar operações
class SubscriptionActions {
  final SubscriptionStatusNotifier subscriptionNotifier;
  final TrialNotifier trialNotifier;
  final BillingNotifier billingNotifier;
  final PurchaseNotifier purchaseNotifier;

  SubscriptionActions({
    required this.subscriptionNotifier,
    required this.trialNotifier,
    required this.billingNotifier,
    required this.purchaseNotifier,
  });

  /// Carrega todos os dados (operação batch)
  /// Útil na inicialização
  Future<void> loadAll() async {
    await Future.wait([
      subscriptionNotifier.loadSubscriptionStatus(),
      trialNotifier.loadTrialInfo(),
      billingNotifier.loadBillingIssues(),
      purchaseNotifier.loadPurchaseHistory(),
    ]);
  }

  /// Sincroniza todos os dados com backend
  /// Útil quando app volta de background
  Future<void> syncAll() async {
    await Future.wait([
      subscriptionNotifier.syncWithBackend(),
      trialNotifier.syncWithBackend(),
      billingNotifier.syncWithBackend(),
      purchaseNotifier.syncWithBackend(),
    ]);
  }

  /// Faz upgrade de subscription
  Future<void> upgradeSubscription({
    required SubscriptionTier newTier,
    required String billingCycle,
  }) async {
    await subscriptionNotifier.upgradeSubscription(
      newTier: newTier,
      billingCycle: billingCycle,
    );
  }

  /// Faz downgrade de subscription
  Future<void> downgradeSubscription({
    required SubscriptionTier newTier,
    required DateTime? effectiveDate,
  }) async {
    await subscriptionNotifier.downgradeSubscription(
      newTier: newTier,
      effectiveDate: effectiveDate,
    );
  }

  /// Cancela subscription
  Future<void> cancelSubscription({
    required String reason,
    String? feedback,
    bool immediateEffect = false,
  }) async {
    await subscriptionNotifier.cancelSubscription(
      reason: reason,
      feedback: feedback,
      immediateEffect: immediateEffect,
    );
  }

  /// Reativa subscription cancelada
  Future<void> reactiveSubscription() async {
    await subscriptionNotifier.reactiveSubscription();
  }

  /// Inicia novo trial
  Future<void> startNewTrial({
    required String productId,
    int durationInDays = 14,
  }) async {
    await trialNotifier.startNewTrial(
      productId: productId,
      durationInDays: durationInDays,
    );
  }

  /// Cancela trial
  Future<void> cancelTrial({required String reason}) async {
    await trialNotifier.cancelTrial(reason: reason);
  }

  /// Faz retry de cobrança falhada
  Future<void> retryFailedBilling({required String issueId}) async {
    await billingNotifier.retryFailedBilling(issueId: issueId);
  }

  /// Resolve problema de cobrança
  Future<void> resolveBillingIssue({
    required String issueId,
    String? resolutionNotes,
  }) async {
    await billingNotifier.resolveBillingIssue(
      issueId: issueId,
      resolutionNotes: resolutionNotes,
    );
  }

  /// Atualiza método de pagamento
  Future<void> updatePaymentMethod({required String paymentMethodToken}) async {
    await billingNotifier.updatePaymentMethod(
      paymentMethodToken: paymentMethodToken,
    );
  }

  /// Compra produto
  Future<void> purchaseProduct({
    required String productId,
    required double amount,
    required PurchaseType purchaseType,
  }) async {
    await purchaseNotifier.purchaseProduct(
      productId: productId,
      amount: amount,
      purchaseType: purchaseType,
    );
  }

  /// Restaura compras anteriores
  Future<void> restorePurchases({bool includeExpired = true}) async {
    await purchaseNotifier.restorePurchases(includeExpired: includeExpired);
  }

  /// Faz retry de compra falhada
  Future<void> retryFailedPurchase({required String purchaseId}) async {
    await purchaseNotifier.retryFailedPurchase(purchaseId: purchaseId);
  }

  void clearAll() {
    subscriptionNotifier.clearState();
    trialNotifier.clearState();
    billingNotifier.clearState();
    purchaseNotifier.clearState();
  }
}
